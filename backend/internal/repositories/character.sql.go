// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: character.sql

package repositories

import (
	"context"

	"github.com/google/uuid"
)

const createCharacter = `-- name: CreateCharacter :one
insert into
    "character" (
        "image",
        "name",
        "anilistId",
        "birthYear",
        "birthMonth",
        "birthDay",
        "bloodType",
        "age",
        "description",
        "gender"
    )
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) returning id, image, name, "anilistId", "birthYear", "birthMonth", "birthDay", "bloodType", age, description, gender
`

type CreateCharacterParams struct {
	Image       string  `json:"image"`
	Name        string  `json:"name"`
	AnilistId   int32   `json:"anilistId"`
	BirthYear   *int32  `json:"birthYear"`
	BirthMonth  *int32  `json:"birthMonth"`
	BirthDay    *int32  `json:"birthDay"`
	BloodType   *string `json:"bloodType"`
	Age         *string `json:"age"`
	Description *string `json:"description"`
	Gender      *string `json:"gender"`
}

func (q *Queries) CreateCharacter(ctx context.Context, arg CreateCharacterParams) (Character, error) {
	row := q.db.QueryRow(ctx, createCharacter,
		arg.Image,
		arg.Name,
		arg.AnilistId,
		arg.BirthYear,
		arg.BirthMonth,
		arg.BirthDay,
		arg.BloodType,
		arg.Age,
		arg.Description,
		arg.Gender,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.Image,
		&i.Name,
		&i.AnilistId,
		&i.BirthYear,
		&i.BirthMonth,
		&i.BirthDay,
		&i.BloodType,
		&i.Age,
		&i.Description,
		&i.Gender,
	)
	return i, err
}

const getAllCharactersByRandomOrder = `-- name: GetAllCharactersByRandomOrder :many
select id, image, name, "anilistId", "birthYear", "birthMonth", "birthDay", "bloodType", age, description, gender from "character" order by random()
`

func (q *Queries) GetAllCharactersByRandomOrder(ctx context.Context) ([]Character, error) {
	rows, err := q.db.Query(ctx, getAllCharactersByRandomOrder)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Name,
			&i.AnilistId,
			&i.BirthYear,
			&i.BirthMonth,
			&i.BirthDay,
			&i.BloodType,
			&i.Age,
			&i.Description,
			&i.Gender,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnimeCharacterRelationByIds = `-- name: GetAnimeCharacterRelationByIds :one
select "animeId", "characterId" from "anime_character" where "animeId" = $1 and "characterId" = $2 limit 1
`

type GetAnimeCharacterRelationByIdsParams struct {
	AnimeId     uuid.UUID `json:"animeId"`
	CharacterId uuid.UUID `json:"characterId"`
}

func (q *Queries) GetAnimeCharacterRelationByIds(ctx context.Context, arg GetAnimeCharacterRelationByIdsParams) (AnimeCharacter, error) {
	row := q.db.QueryRow(ctx, getAnimeCharacterRelationByIds, arg.AnimeId, arg.CharacterId)
	var i AnimeCharacter
	err := row.Scan(&i.AnimeId, &i.CharacterId)
	return i, err
}

const getCharacterByAnilistId = `-- name: GetCharacterByAnilistId :one
select id, image, name, "anilistId", "birthYear", "birthMonth", "birthDay", "bloodType", age, description, gender from "character" where "anilistId" = $1 limit 1
`

func (q *Queries) GetCharacterByAnilistId(ctx context.Context, anilistid int32) (Character, error) {
	row := q.db.QueryRow(ctx, getCharacterByAnilistId, anilistid)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.Image,
		&i.Name,
		&i.AnilistId,
		&i.BirthYear,
		&i.BirthMonth,
		&i.BirthDay,
		&i.BloodType,
		&i.Age,
		&i.Description,
		&i.Gender,
	)
	return i, err
}

const getCharacterById = `-- name: GetCharacterById :many
select
    character.id, character.image, character.name, character."anilistId", character."birthYear", character."birthMonth", character."birthDay", character."bloodType", character.age, character.description, character.gender,
    "anime"."name" as "anime",
    count("like"."userId") as "likes",
    case
        when exists (
            select 1
            from "like"
            where
                "like"."characterId" = "character"."id"
                and "like"."userId" = $2::text
        ) then true
        else false
    end as "liked"
from
    "character"
    join "anime_character" on "anime_character"."characterId" = "character"."id"
    join "anime" on "anime"."id" = "anime_character"."animeId"
    left join "like" on "like"."characterId" = "character"."id"
where
    "character"."id" = $1
group by
    "character"."id",
    "anime"."id"
order by "anime"."anilistId"
`

type GetCharacterByIdParams struct {
	ID     uuid.UUID `json:"id"`
	UserId *string   `json:"userId"`
}

type GetCharacterByIdRow struct {
	ID          uuid.UUID `json:"id"`
	Image       string    `json:"image"`
	Name        string    `json:"name"`
	AnilistId   int32     `json:"anilistId"`
	BirthYear   *int32    `json:"birthYear"`
	BirthMonth  *int32    `json:"birthMonth"`
	BirthDay    *int32    `json:"birthDay"`
	BloodType   *string   `json:"bloodType"`
	Age         *string   `json:"age"`
	Description *string   `json:"description"`
	Gender      *string   `json:"gender"`
	Anime       string    `json:"anime"`
	Likes       int64     `json:"likes"`
	Liked       bool      `json:"liked"`
}

func (q *Queries) GetCharacterById(ctx context.Context, arg GetCharacterByIdParams) ([]GetCharacterByIdRow, error) {
	rows, err := q.db.Query(ctx, getCharacterById, arg.ID, arg.UserId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCharacterByIdRow
	for rows.Next() {
		var i GetCharacterByIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Name,
			&i.AnilistId,
			&i.BirthYear,
			&i.BirthMonth,
			&i.BirthDay,
			&i.BloodType,
			&i.Age,
			&i.Description,
			&i.Gender,
			&i.Anime,
			&i.Likes,
			&i.Liked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkCharacterToAnime = `-- name: LinkCharacterToAnime :exec
insert into "anime_character" ("animeId", "characterId") values ($1, $2)
`

type LinkCharacterToAnimeParams struct {
	AnimeId     uuid.UUID `json:"animeId"`
	CharacterId uuid.UUID `json:"characterId"`
}

func (q *Queries) LinkCharacterToAnime(ctx context.Context, arg LinkCharacterToAnimeParams) error {
	_, err := q.db.Exec(ctx, linkCharacterToAnime, arg.AnimeId, arg.CharacterId)
	return err
}

const searchCharacter = `-- name: SearchCharacter :many
select distinct on ("character"."id") character.id, character.image, character.name, character."anilistId", character."birthYear", character."birthMonth", character."birthDay", character."bloodType", character.age, character.description, character.gender, "anime"."name" as "anime"
from
    "character"
    join "anime_character" on "anime_character"."characterId" = "character"."id"
    join "anime" on "anime"."id" = "anime_character"."animeId"
where "anime"."name" ilike $1 or "character"."name" ilike $1
order by "character"."id", "character"."anilistId"
`

type SearchCharacterRow struct {
	ID          uuid.UUID `json:"id"`
	Image       string    `json:"image"`
	Name        string    `json:"name"`
	AnilistId   int32     `json:"anilistId"`
	BirthYear   *int32    `json:"birthYear"`
	BirthMonth  *int32    `json:"birthMonth"`
	BirthDay    *int32    `json:"birthDay"`
	BloodType   *string   `json:"bloodType"`
	Age         *string   `json:"age"`
	Description *string   `json:"description"`
	Gender      *string   `json:"gender"`
	Anime       string    `json:"anime"`
}

func (q *Queries) SearchCharacter(ctx context.Context, name string) ([]SearchCharacterRow, error) {
	rows, err := q.db.Query(ctx, searchCharacter, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchCharacterRow
	for rows.Next() {
		var i SearchCharacterRow
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Name,
			&i.AnilistId,
			&i.BirthYear,
			&i.BirthMonth,
			&i.BirthDay,
			&i.BloodType,
			&i.Age,
			&i.Description,
			&i.Gender,
			&i.Anime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharacterById = `-- name: UpdateCharacterById :exec
update "character" set "image" = $1, "name" = $2, "birthYear" = $3, "birthMonth" = $4, "birthDay" = $5, "bloodType" = $6, "age" = $7, "description" = $8, "gender" = $9 where "id" = $10
`

type UpdateCharacterByIdParams struct {
	Image       string    `json:"image"`
	Name        string    `json:"name"`
	BirthYear   *int32    `json:"birthYear"`
	BirthMonth  *int32    `json:"birthMonth"`
	BirthDay    *int32    `json:"birthDay"`
	BloodType   *string   `json:"bloodType"`
	Age         *string   `json:"age"`
	Description *string   `json:"description"`
	Gender      *string   `json:"gender"`
	ID          uuid.UUID `json:"id"`
}

func (q *Queries) UpdateCharacterById(ctx context.Context, arg UpdateCharacterByIdParams) error {
	_, err := q.db.Exec(ctx, updateCharacterById,
		arg.Image,
		arg.Name,
		arg.BirthYear,
		arg.BirthMonth,
		arg.BirthDay,
		arg.BloodType,
		arg.Age,
		arg.Description,
		arg.Gender,
		arg.ID,
	)
	return err
}
